package net.mortaxx.software.FTLEdit;

/*
Copyright (c) 2009-2019, Christian Hecht. 
All rights reserved.

This software is published under the "Simplified BSD License" (2-clause license)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FTLEdit project.

These class is part of program FTLEdit.

FTLEdit includes and uses libraries and source code from some other contributors:

--> FileTree.java - Extension of JTree class to show a file system explorer - Copyright 2005 by Janni Kovacs
- Copied from the tutorial at java-forum.org
- For further information, see <http://www.java-forum.org/java-faq-beitraege/23430-jtree-anwendung-1-directorychooser.html>

--> Parts of GUI code generated by GuiGenie - Copyright (c) 2004 Mario Awad.
- Home Page http://guigenie.cjb.net - Check often for new versions!

--> Rsyntaxtextarea/RSTALanguageSupport/AutoComplete
Copyright (c) 2012, Robert Futrell - https://github.com/bobbylight

--> Rhino
Copyright (c) 2012, Mozilla Corporation - https://github.com/mozilla/rhino

--> Java Native Access (JNA)
Copyright (c) 2007-2019 by Timothy Wall - https://github.com/java-native-access/jna#readme

*/

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Writer;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.OutputStreamWriter;
import java.net.MalformedURLException;
import java.nio.charset.Charset;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.HashMap;
import java.util.Locale;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.swing.event.EventListenerList;
//import javax.xml.bind.DatatypeConverter;

import net.mortaxx.software.FlatFusionTools.EncodingGuess;
import net.mortaxx.software.FlatFusionTools.FlatFusionEventListener;

public class FTLEditModel {

	
// --> SWT branch
	
	/* ###################################################################
	 * Model-Klasse fürr FlatFusion Edit, führt alle Dateioperationen durch
	 #####################################################################*/
	
	private File actualSourceFile = null;
	private String actualSourceFileSuffix = null;
	private String actualFileContent = "";
	private Charset actualCharset = null;
	private Charset fileWriteCharset = null;
	private Charset preferredCharset = null;
	private Boolean useFileEncoding;
	private EventListenerList listenerList = null;
	private Preferences editorPrefs;
	private char[] cbuf;
	private InputStreamReader isreader;
	private File tempFile = null;
//	private CodepageDetectorProxy detector;
	private Locale currentlocale;

//	private HashMap<String, HashMap<String, String>> actualBookMarks = null;

// Constructor
	
	public FTLEditModel(Locale currentloc) {
		
		String tempdir = System.getProperty("java.io.tmpdir");
		System.out.println(tempdir);
		// Fix für Linux - hier wird der Pfad für temporäre Files ohne Slash am Ende ausgegeben
		if (tempdir.endsWith("/") == false) {
			tempdir = tempdir + "/";
		}
		System.out.println(tempdir);
		tempFile = new File(tempdir + "flatfusionedittmp.html");
		listenerList = new EventListenerList();
		editorPrefs = Preferences.userNodeForPackage(this.getClass());
		if (editorPrefs.get("saveEncoding", "FILE").toString().equals("FILE")) {
			useFileEncoding = true;
		}
		else {
			useFileEncoding = false;
			preferredCharset = Charset.forName((editorPrefs.get("saveEncoding", "FILE").toString()));
		}
		
		currentlocale = currentloc;
		
//---- cpdetector
		
//		detector = CodepageDetectorProxy.getInstance(); // A singleton.
		  
//Add the implementations of info.monitorenter.cpdetector.io.ICodepageDetector: 
//This one is quick if we deal with unicode codepages:
		
//		detector.add(new ByteOrderMarkDetector()); 
//The first instance delegated to tries to detect the meta charset attribut in html pages.
		 	
//		detector.add(new ParsingDetector(true)); // be verbose about parsing.
//This one does the tricks of exclusion and frequency detection, if first implementation is 
//unsuccessful:
//		detector.add(JChardetFacade.getInstance()); // Another singleton.
		    
//		detector.add(ASCIIDetector.getInstance()); // Fallback, see javadoc.
//		actualBookMarks = new HashMap<String, HashMap<String, String>>();
	}
	
	public String readFile(File f) {

		Charset detectedCharset = null;
		int reallength = 0; //Tatsächliche Dateilänge in Zeichen
		
		if (f.isFile() == true) {
			

			try {
				
				detectedCharset = Charset.forName(EncodingGuess.guessEncodingFromFile(f, true, false, currentlocale)); //detector.detectCodepage(f.toURI().toURL());
			} catch (MalformedURLException e1) {
					// TODO Auto-generated catch block
				e1.printStackTrace();
			} catch (IOException e1) {
					// TODO Auto-generated catch block
				e1.printStackTrace();
			}
			System.out.println(detectedCharset);
//			FileInputStream fistest = null;
			FileInputStream fisreal = null;
		
			try {
				
//				fistest = new FileInputStream(f);
				fisreal = new FileInputStream(f);
				
			} catch (FileNotFoundException e2) {
				
				// TODO Auto-generated catch block
				e2.printStackTrace();
			}

//			InputStream in = new BufferedInputStream(fistest);
			
// Klasse zur Erkennung der Kodierung initialisieren
			
//			CharsetDetector csd = new CharsetDetector();
		
// Eingabestream setzen
			
/*			try {
				csd.setText(in);
			} catch (IOException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			} */

// Kodierung erkennen
			
//			CharsetMatch csm = csd.detect();

// Zeichen-Array mit der Dateilänge in Byte initialisieren - bei Unicode-Dateien
// ist allerdings die Länge in Bytes länger als die tatsächliche Länge in Zeichen
// Daher hängen dann am Ende des Arrays "NULL" Zeichen
			
			cbuf = new char[(int)f.length()];
	
// Neuen Reader mit der erkannten Kodierung erzeugen
			
//			isreader = new InputStreamReader(fisreal, Charset.forName(csm.getName()));
			isreader = new InputStreamReader(fisreal, detectedCharset);
			try {
				
// Datei einlesen, der Rückgabewert ist die tatsächliche Länge in Zeichen
				
				reallength = isreader.read(cbuf);
				
			} catch (IOException e2) {
				
				// TODO Auto-generated catch blockS
				e2.printStackTrace();
			}
			
			actualSourceFile = f;
			actualCharset = detectedCharset;

// Dateiendung ermitteln
			
			actualSourceFileSuffix = f.getName().substring(f.getName().lastIndexOf('.')+1);

// Die überflüssigen Zeichen am Ende des Zeichen-Arrays abschneiden
// in dem ein String in der tatsächlichen Länge in Zeichen erzeugt wird
			
			String realstring = new String( cbuf, 0, reallength ) ;

// Temporäre Datei für Anzeige der Vorschau wegschreiben
			
			this.writeTempFile(realstring);
			return realstring;

		
		}
		else {
			
			actualSourceFile = null;
			actualCharset = Charset.defaultCharset();
			this.writeTempFile("");
			return new String("");
		}
		
	}
	
	public void writeFile (String fileContent) {
		
		if (useFileEncoding == true) {
			fileWriteCharset = actualCharset;
		}
		else {
			fileWriteCharset = preferredCharset;
		}
		Writer fileWriter = null;
		try {
			fileWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(actualSourceFile.getAbsolutePath()), fileWriteCharset));
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			fileWriter.write(fileContent);
			fileWriter.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		this.fireFileSaved();
	}
	
	public boolean isSourceFileChanged(String viewSourceContent) {
		
// Prüfen ob der Inhalt der gelesenen Datei vom Inhalt der Oberfläche abweicht
		
		if (actualFileContent.equals(viewSourceContent)) {
			return false;	
		}
		else {
			return true;
		}
		
	}
	
	public File getActualSourceFile() {
		
		return actualSourceFile;
		
	}

	public String getActualSourceFileSuffix() {

// Getter-Methode für aktuelle Dateiendung
		
		return actualSourceFileSuffix;
		
	}
	
	public void setActualFileContent(String content) {
		
// Setter-Methode für den Dateiinhalt der aktuell angezeigten Datei
		
		actualFileContent = content;
		
	}

	public void setActualFileName(String filename) {
		
// Setter-Methode für das Dateiobjekt der aktuell angezeigten Datei
				
		File file = new File(filename);
		actualSourceFile = file;
				
	}
	
	public void setActualFileEncoding(Charset cs) {
		
// Setter-Methode für die Zeichenkodierung der aktuellen Datei
						
		actualCharset = cs;
						
	}
	
	public boolean isFileExisting (String filename) {
		
		boolean fileExists = false;
		
		File filetoCheck = new File(filename);
		
		fileExists = filetoCheck.exists();
		
		return fileExists;
	}
	
	public void deleteFile(String filename) {
		
		File filetodelete = new File(filename);
		
		if(filetodelete.exists()){
			
			filetodelete.delete();
			
		}
		
	}
	
// Methode zum Hinzufügen eines Listeners
	
	public void addListener(FlatFusionEventListener aListener) 
	{
		listenerList.add(FlatFusionEventListener.class, aListener);
	}
	

// Methode zum Feuern eines Events, wenn eine Datei erfolgreich gespeichert wurde 
	 
	protected void fireFileSaved()
	{
	     // Ermittle registrierte Listener
	     Object[] listeners = listenerList.getListenerList();

	     // informiere alle Listener über das Event in rückwärtiger Folge
	     for (int i = listeners.length-2; i>=0; i-=2) 
	     {
	         if (listeners[i]==FlatFusionEventListener.class) 
	             ((FlatFusionEventListener)listeners[i+1]).editorFileSaved();
	     }
	}

// Getter-Methode für das Objekt mit den Benutzereinstellungen
	public Preferences getUserPrefs() {
		
		return editorPrefs;
	}
	
// Benutzereinstellungen abspeichern
	
	public void storeUserPrefs (String prefkey, String prefvalue) throws BackingStoreException {
		
		editorPrefs.put(prefkey, prefvalue);
		editorPrefs.flush();
	}
	
// Getter-Methode für das verwendete temporäre File
	
	public File getTempFile() {
		
		if (actualSourceFile != null) {
		
			return tempFile;
		}
		else {

			return null;
		}

	}
	
	public void writeTempFile (String fileContent) {

		if (useFileEncoding == true) {
			fileWriteCharset = actualCharset;
		}
		else {
			fileWriteCharset = preferredCharset;
		}
		Writer fileWriter = null;

		try {
			fileWriter = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(tempFile.getAbsolutePath()), fileWriteCharset));
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		try {
			fileWriter.write(fileContent);
			fileWriter.close();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}

	}

    public void storeBookmarks(HashMap<String, String> bookmarks) {

// Das Objekt der HashMap mit den einzelnen Codestellen als String serialisieren und encoden und dann
// abspeichern

        String serialzedString = "";
    	if (actualSourceFile != null && actualSourceFile.isFile() == true) {
// Der Preference-Key kann maximal 80 Stellen haben, daher einen Hash für den Filenamen erzeugen und unter diesem abspeichern
        	MessageDigest md = null;
			try {
				md = MessageDigest.getInstance("MD5");
			} catch (NoSuchAlgorithmException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
            md.update(actualSourceFile.getAbsolutePath().getBytes());
            byte[] digest = md.digest();
            StringBuilder hex = new StringBuilder();
            for (byte b : digest) {
                hex.append(String.format("%02x", b));
            }
            String myHash = hex.toString().toUpperCase();
            try {
            	ByteArrayOutputStream bo = new ByteArrayOutputStream();

            	ObjectOutputStream so = new ObjectOutputStream(bo);
            	so.writeObject(bookmarks);
            	so.flush();
            	serialzedString = Base64.getEncoder().encodeToString(bo.toByteArray()); 

            }	

            catch (Exception e) {

            	e.printStackTrace();

            }

            try {
            	storeUserPrefs(myHash, serialzedString);
            } catch (BackingStoreException e) {
			// TODO Auto-generated catch block
            	e.printStackTrace();
            }
    	}
    }

    public HashMap<String, String> getBookmarks() {

    	HashMap<String, String> bookmarks = null;
    	if (actualSourceFile != null && actualSourceFile.isFile() == true) {
 		
// Der Preference-Key kann maximal 80 Stellen haben, daher einen Hash für den Filenamen erzeugen und mit diesem lesen
    		
        	MessageDigest md = null;
			try {
				md = MessageDigest.getInstance("MD5");
			} catch (NoSuchAlgorithmException e1) {
				// TODO Auto-generated catch block
				e1.printStackTrace();
			}
            md.update(actualSourceFile.getAbsolutePath().getBytes());
            byte[] digest = md.digest();
            
            StringBuilder hex = new StringBuilder();
            for (byte b : digest) {
                hex.append(String.format("%02x", b));
            }
            String myHash = hex.toString().toUpperCase();
//            		DatatypeConverter
//              .printHexBinary(digest).toUpperCase();
//            System.out.println(myHash);
            String prefString = getUserPrefs().get(myHash, "");
         // Das Objekt aus dem gelesenen String wieder decoden und dann deserialisieren und die daraus resultierende HashMap zurückgeben
            if (prefString != "") {
            	try {
            		byte b[] = Base64.getDecoder().decode((prefString.getBytes())); 
            		ByteArrayInputStream bi = new ByteArrayInputStream(b);
            		ObjectInputStream si = new ObjectInputStream(bi);
            		bookmarks = (HashMap<String, String>) si.readObject();
            	} catch (Exception e) {
            		e.printStackTrace();
            	}
            }
    	}
        return bookmarks;
    }
}
