package net.mortaxx.software.FTLEdit;

/*
Copyright (c) 2009-2019, Christian Hecht. 
All rights reserved.

This software is published under the "Simplified BSD License" (2-clause license)

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice, this
   list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright notice,
   this list of conditions and the following disclaimer in the documentation
   and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

The views and conclusions contained in the software and documentation are those
of the authors and should not be interpreted as representing official policies,
either expressed or implied, of the FTLEdit project.

These class is part of program FTLEdit.

FTLEdit includes and uses libraries and source code from some other contributors:

--> FileTree.java - Extension of JTree class to show a file system explorer - Copyright 2005 by Janni Kovacs
- Copied from the tutorial at java-forum.org
- For further information, see <http://www.java-forum.org/java-faq-beitraege/23430-jtree-anwendung-1-directorychooser.html>

--> Parts of GUI code generated by GuiGenie - Copyright (c) 2004 Mario Awad.
- Home Page http://guigenie.cjb.net - Check often for new versions!

--> Rsyntaxtextarea/RSTALanguageSupport/AutoComplete/RSTAUI
Copyright (c) 2012, Robert Futrell - https://github.com/bobbylight

--> Rhino
Copyright (c) 2012, Mozilla Corporation - https://github.com/mozilla/rhino

--> Java Native Access (JNA)
Copyright (c) 2007-2019 by Timothy Wall - https://github.com/java-native-access/jna#readme

*/

import java.awt.AWTEvent;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Toolkit;
import java.awt.event.AWTEventListener;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.WindowAdapter;
import java.awt.event.WindowEvent;

import java.io.File;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Locale;
import java.util.Random;
import java.util.ResourceBundle;
import java.util.prefs.BackingStoreException;
import java.util.prefs.Preferences;

import javax.swing.DefaultDesktopManager;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JDesktopPane;
import javax.swing.JFrame;
import javax.swing.JMenuItem;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JPopupMenu;
import javax.swing.JTabbedPane;
import javax.swing.JTree;
import javax.swing.KeyStroke;
import javax.swing.AbstractAction;
import javax.swing.UIManager;
import javax.swing.event.ChangeEvent;
import javax.swing.event.ChangeListener;
import javax.swing.event.TreeSelectionEvent;
import javax.swing.event.TreeSelectionListener;
import javax.swing.text.BadLocationException;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreePath;

import org.fife.rsta.ac.js.tree.JavaScriptTreeNode;
import org.fife.rsta.ac.SourceTreeNode;
import org.fife.rsta.ac.java.rjc.ast.ASTNode;
import org.fife.rsta.ui.search.ReplaceDialog;
import org.fife.rsta.ui.search.SearchEvent;
import org.fife.rsta.ui.search.SearchListener;
import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;
import org.fife.ui.rsyntaxtextarea.SyntaxConstants;
import org.fife.ui.rtextarea.GutterIconInfo;
import org.fife.ui.rtextarea.SearchContext;
import org.fife.ui.rtextarea.SearchEngine;
import org.fife.ui.rtextarea.SearchResult;
import org.mozilla.javascript.ast.AstNode;

import net.mortaxx.software.FlatFusionTools.BareBonesBrowserLaunch;
import net.mortaxx.software.FlatFusionTools.FTLEditEventListener;

//import com.apple.eawt.ApplicationEvent;

//import chrriis.dj.nativeswing.swtimpl.ApplicationMessageHandler;
//import chrriis.dj.nativeswing.swtimpl.NativeInterface;

/* Controller-Klasse für FlatFusionEdit - erzeugt den GUI-View und das DatenModel
 * und reagiert auf die Ereignisses des Views
 */

public class FTLEditController implements SearchListener {

	FTLEditMainView editorView;
//	FTLEditBrowserView editorPreviewDialog;
	FTLEditPreferencesView editorPreferencesView;
	FTLEditModel editorModel;
	FTLEditController editorController;
	JFrame frame;
	private ResourceBundle messagebundle;
	private Locale currentlocale;
	
	boolean g_flg_mainframe; // Aufruf aus FlatFusion
	
	String projectDir;
	String projectFile;
	boolean editMode = false;
	
	public FTLEditController(String projectdir, boolean mainframe, String startfile) {

	
		g_flg_mainframe = mainframe;
		projectFile = startfile;
		editorController = this;
		
	     try {

//	       UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());
	       
	     }
	     catch(Exception e){
	    	 
	       e.printStackTrace();
	     }
		
		  String systemlocale = System.getProperty("user.language");
		  
		  if (systemlocale.equals("de")){
			  currentlocale = new Locale("de", "DE");  
		  }
		  else {
			  currentlocale = new Locale("en", "EN");
		  }
		  
		  messagebundle = ResourceBundle.getBundle("resources.MessagesFFE", currentlocale);

// Model-Objekt erzeugen
			 
			 editorModel = new FTLEditModel(currentlocale);
			 
// Bildschirmgröße ermitteln
		     
		 Dimension screensize = Toolkit.getDefaultToolkit().getScreenSize();
		     
// Fenster mit Editor und Dateibaum erzeugen und den View daran hängen

	     frame = new JFrame ("FTLEdit");
	     
	     if (g_flg_mainframe == false) {
	    	 
	    	 frame.setDefaultCloseOperation (JFrame.DO_NOTHING_ON_CLOSE); 
	     }
	     else {
		     frame.setDefaultCloseOperation (JFrame.DO_NOTHING_ON_CLOSE);
	     }

	     frame.pack();
	     frame.setSize(Integer.parseInt(editorModel.getUserPrefs().get("windowWidth", "800")), Integer.parseInt(editorModel.getUserPrefs().get("windowHeight", "600")));

// Vorschaufenster erzeugen, dieses ist ein eigener JDialog-Frame
	     
//		 if (System.getProperty("os.name").startsWith("Mac OS")) {
// Auf dem Mac ist der JDialog nur ein Wrapper für die Safari-Kontrolle mit Applescript
//			 editorPreviewDialog = new FTLEditBrowserViewMac( null, messagebundle.getString("018"), false ); 
	  		
//		 } else {
// Vorschaufenster für JCEF-Browser anlegen
//			 editorPreviewDialog = new FTLEditBrowserView( null, messagebundle.getString("018"), false );

//		 }

//		 editorPreviewDialog.pack();
		 
// Fenster-Listener für Hauptfenster anlegen
	     
	     frame.addWindowListener(new EditorWindowListener(this));
	     
// Größe des Hauptfensters ermitteln
		 
		 Dimension framesize = frame.getSize();				     
		 
// Zuletzt verwendetes Verzeichnis holen, wenn der Aufruf standalone erfolgt und keine zu öffnende Datei übergeben wurde
		 
		 if (g_flg_mainframe == false && startfile == null) {
			 
// Wenn noch kein Verzeichnis gespeichert, das übergebene Homeverzeichnis verwenden
			 
			 projectDir = editorModel.getUserPrefs().get("lastUsedDirectory", projectdir);
		 }
		 else if (g_flg_mainframe == false && startfile != null){
			 
			 projectDir = projectdir;
			 projectFile = startfile;
			 
		 }
		 else if (g_flg_mainframe == true) {
			 
// Aufruf erfolgt aus FlatFusion - Übergebenes Verzeichnis übernehmen
			 
			 projectDir = projectdir;
		 }

// View-Objekt erzeugen
		
		 editorView = new FTLEditMainView(projectDir);
		 
		 editorView.addReplaceDialog(frame, this);

// Das Vorschau-Fenster wird standardmäßig immer unterhalb des Hauptfensters angezeigt 
// und erhält die restliche Bildschirmhöhe zugewiesen, wenn es das erste Mal angezeigt wird
					     
//		editorPreviewDialog.setSize(Integer.parseInt(editorModel.getUserPrefs().get("previewWindowWidth", String.valueOf(framesize.width))), Integer.parseInt(editorModel.getUserPrefs().get("previewWindowHeight", String.valueOf((screensize.height - (framesize.height + 60))))));			     
//		editorPreviewDialog.setLocation(Integer.parseInt(editorModel.getUserPrefs().get("previewWindowLocationX", "1")), Integer.parseInt(editorModel.getUserPrefs().get("previewWindowLocationY", String.valueOf(framesize.height + 30))));
//		editorPreviewDialog.setDefaultCloseOperation(JFrame.DO_NOTHING_ON_CLOSE);
// JTree Objekt holen und lokale Klasse mit TreeSelectionListener daran hängen
		 
		 editorView.getFileTree().addTreeSelectionListener(new FileTreeListener(editorView.getFileTree(), this));
		 editorView.getJSOutlineTree().addTreeSelectionListener(new OutlineTreeListener(editorView.getJSOutlineTree(), this));
//		 editorView.getJavaOutlineTree().addTreeSelectionListener(new OutlineTreeListener(editorView.getJavaOutlineTree(), this));
		 
// ToggleButton für Umschalten zwischen Anzeige- und Editiermodus holen und ActionListener setzen	 
		 editorView.getEditDisplayButton().addActionListener(new ButtonListener(this));
		 
// Speicher-Button holen und ActionListener setzen
		 editorView.getSaveButton().addActionListener(new ButtonListener(this));
		 
// Button für Aktualisierung der Vorschau holen und ActionListener setzen
		 editorView.getRefreshPreviewButton().addActionListener(new ButtonListener(this));
		 
// Button für "Neue Datei" holen und ActionListener setzen
		 editorView.getNewFileButton().addActionListener(new ButtonListener(this));
		 
// Button für "Datei löschen" holen und ActionListener setzen
		 editorView.getRemoveFileButton().addActionListener(new ButtonListener(this));

// Button für "Verzeichnis wechseln" holen und ActionListener setzen
		 editorView.getChangeDirectoryButton().addActionListener(new ButtonListener(this));
	
// Button für "Einstellungen" holen und ActionListener setzen
		 editorView.getPreferencesButton().addActionListener(new ButtonListener(this));

// Button für "Nächsten Treffer suchen" holen und ActionListener setzen
		 editorView.getSearchNextButton().addActionListener(new ButtonListener(this));

// Button für "Vorigen Treffer suchen" holen und ActionListener setzen
		 editorView.getSearchPrevButton().addActionListener(new ButtonListener(this));

// Textfeld für Suchstring holen und ActionListener setzen
		 
		 editorView.getSearchTextField().addActionListener(new ActionListener() {
	          public void actionPerformed(ActionEvent e) {
	        	  editorView.getSearchNextButton().doClick(0);
	          }
	       });
		
		 editorView.getTabbedPanel().addChangeListener(new ChangeListener() {

	    		public void stateChanged(ChangeEvent e) {
	                System.out.println("Tab: " + editorView.getTabbedPanel().getSelectedIndex());
	                if (editorView.getTabbedPanel().getSelectedIndex() != -1) {
	                	List<RSyntaxTextArea> areas = MXNewSourceTabFactory.findAllChildren((JComponent)editorView.getTabbedPanel().getSelectedComponent(), RSyntaxTextArea.class);
	                	if (areas.size() > 0) {
	                		RSyntaxTextArea ta = areas.get(0);
	                		editorView.setRefsOfActSourceTab();
	                		editMode = ta.isEditable();
	                		if (editorView.getEditorTextArea() != null) {
	                			editorView.setEditDisplayMode(ta.isEditable());
	                		}

	                		String sSyntax = ta.getSyntaxEditingStyle();
	                		if (sSyntax == SyntaxConstants.SYNTAX_STYLE_JAVA) {
	            		    
	                			editorView.getJavaOutlineTree().listenTo(ta);
	                		
	                		} else {
	                			editorView.getJSOutlineTree().listenTo(ta);
	                		
	                		}
	                	
	                		JPanel pan = (JPanel)ta.getParent().getParent().getParent();
	                		Object[] openFile = editorModel.isFileAlreadyOpen(pan.getName());
						
	                		if (openFile != null) {
	                			editorModel.setActualFileContent((String)openFile[1]);
	                			editorModel.setActualSourceFile((File)openFile[2]);
	                			editorModel.setActualFileEncoding((Charset)openFile[3]);
	                		}
	                		editorView.showBookmarks(editorModel.getBookmarks());
	                		editorView.setSourceContextSuffix(editorModel.getActualSourceFileSuffix());
//	                	tree2.listenTo(ta);
	                	}
	                }
	    			
	    		}
	        });
		 
		 editorView.getTabbedPanel().addListener(new MXJTabbedPaneEventListener(this));
		 
		 if (projectFile == null) {
// Wurzelverzeichnis des Dateibaumes selektieren
		 
			 editorView.getFileTree().setSelectionRow(0);
		 
		 }
		 else {
			 
// Es wurde eine Datei zum Öffnen übergeben, dann diese im Baum selektieren 
			 editorView.selectNodeByPath(projectFile);
		 }
	     
// Behandler fuer Apple-spezifische Ereignisse registrieren
		 
//		  NativeInterface.setApplicationMessageHandler(new EditorMessageHandler(this));
// Einen Thread registrieren, der ausgeführt wird, wenn die Anwendung beendet wird
// Der Thread ruft dann die Methode zum Sichern der Benutzereinstellungen auf
	     
	     Runtime.getRuntime().addShutdownHook(new Thread() {
// This method is called during shutdown
	         public void run() {

	        	 setUserPrefs();
	         }
	     });
	     

	     frame.getContentPane().add (editorView);
	     
// Handler für Tastaturereignisse registrieren
	     
//	     initGlobalKeyListener();

// Unter Mac OS den Apple-spezifischen Handler für das Quit-Menü initialisieren
	  		
	  	if (System.getProperty("os.name").startsWith("Mac OS")) {
//	  		this.setupMacOSXApplicationListener();	 
	  	}	
	  		
// Zuletzt die Fenster sichtbar machen - dabei zuerst die Vorschau, dann
// das Hauptfenster, so ist dieses im Vordergrund
	 	     
//	  	if (System.getProperty("os.name").startsWith("Mac OS") != true) {
// Auf dem Mac bleibt der JDialog unsichtbar, da die Vorschau über Safari direkt erfolgt
//	  		editorPreviewDialog.setVisible(true);
//	  	}

	 	frame.setVisible (true);
// Größe des linken SplitContainers auf 85 % setzen, dies geht erst wenn er sichtbar ist
	 	editorView.setDividerLocationEditSplitPane(0.85);
	
// Größe des unteren SplitContainers von Outliner/Bookmarks auf 30 % setzen, dies geht erst wenn er sichtbar ist
	 	editorView.setDividerLocationTreeSplitPane(0.6);
	 	 	
// STRG + S für Sichern für den gesamten Editor-View abfragen

        InputMap imWindows = editorView.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW);
        imWindows.put(KeyStroke.getKeyStroke("ctrl pressed S"), "Save");

        editorView.getActionMap().put("Save", new AbstractAction(){

            public void actionPerformed(ActionEvent e) {
                System.out.println("Ctrl + S: Saving");
                editorView.getSaveButton().doClick(0);
                JPanel source = (JPanel) e.getSource();
                System.out.println(source.getName());
            }

        });

// Bookmarks setzen/loeschen fuer Editor-Textarea
        InputMap imEditorArea = editorView.getEditorTextArea().getInputMap(JComponent.WHEN_FOCUSED);
        imEditorArea.put(KeyStroke.getKeyStroke("ctrl pressed F2"), "ToggleBookmark");
// Suchen/Ersetzen Dialog
        imEditorArea.put(KeyStroke.getKeyStroke("ctrl pressed H"), "Replace");
        editorView.getEditorTextArea().getActionMap().put("Replace", new ShowReplaceDialogAction());
        
// Mouse-Listener fuer Klick auf eine Zeile in den Lesezeichen
        
        MouseListener bookmarktreemouselistener = new MouseAdapter() {

            @Override
            public void mousePressed(MouseEvent e) {

                int row = editorView.getBookmarkTree().getRowForLocation(e.getX(), e.getY());
                TreePath path = editorView.getBookmarkTree().getPathForLocation(e.getX(), e.getY());
                if (row != -1) {
                    if (e.getClickCount() == 1) {
                        DefaultMutableTreeNode node = (DefaultMutableTreeNode)
                        path.getLastPathComponent();
                        /* if nothing is selected */

                        if (node == null) return;
         /* retrieve the node that was selected */
                        String[] nodeInfo = (String[])node.getUserObject();
         /* React to the node selection. */
                        editorView.getEditorTextArea().requestFocusInWindow();
                        editorView.getEditorTextArea().setCaretPosition(Integer.valueOf(nodeInfo[1]));
                    }

                }

            }

        };

        editorView.getBookmarkTree().addMouseListener(bookmarktreemouselistener);
        this.setBookmarkAction();
/*        editorView.getEditorTextArea().getActionMap().put("ToggleBookmark", new AbstractAction(){
        	
            public void actionPerformed(ActionEvent e) {

            	System.out.println("F2: Bookmarking");
            	HashMap<String, String> bookmarks = new HashMap();
            	try {
            		editorView.getScrollPaneEditorTextArea().getGutter().toggleBookmark(editorView.getEditorTextArea().getCaretLineNumber());
            	} catch (BadLocationException e1) {
                                   // TODO Auto-generated catch block
            		e1.printStackTrace();
                }

            	GutterIconInfo[] gutterinfos = editorView.getScrollPaneEditorTextArea().getGutter().getBookmarks();
            	DefaultTreeModel outlinemodel = (DefaultTreeModel)editorView.getBookmarkTree().getModel();
           		DefaultMutableTreeNode outlineroot = (DefaultMutableTreeNode)outlinemodel.getRoot();

           		outlineroot.removeAllChildren();
           		int startoffset = 0;
           		int endoffset = 0;
           		
            	for( int i = 0; i < gutterinfos.length; i++ ) {

           			int offset = gutterinfos[i].getMarkedOffset();

           			try {
           				startoffset = editorView.getEditorTextArea().getLineStartOffset(editorView.getEditorTextArea().getLineOfOffset(offset));
           			} catch (BadLocationException e2) {
                                              // TODO Auto-generated catch block
           				e2.printStackTrace();
           			}
           			try {
           				endoffset = editorView.getEditorTextArea().getLineEndOffset(editorView.getEditorTextArea().getLineOfOffset(offset));
           			} catch (BadLocationException e2) {
                                              // TODO Auto-generated catch block
           				e2.printStackTrace();
            		}
            		String line = null;
            		
            		try {
            			line = editorView.getEditorTextArea().getText(startoffset, endoffset - startoffset);
           			} catch (BadLocationException e1) {	
                                  // TODO Auto-generated catch block
           				e1.printStackTrace();
            		}

            		String[] tokens = { line, Integer.toString(offset) };
            		bookmarks.put(Integer.toString(offset), line);
            		OutlineTreeNode tokenNode = new OutlineTreeNode(tokens);

            		outlineroot.add(tokenNode);

            	}
            	outlinemodel.reload(outlineroot);
            	editorModel.storeBookmarks(bookmarks);
            	
            }

        });*/

	}

// Getter Methode für das Model
	
	public FTLEditModel getModel() {
		return editorModel;
	}

// Getter Methode für den Haupt-View
	
	public FTLEditMainView getMainView() {
		return editorView;
	}

// Getter Methode für den Vorschau-View
	
/*	public FTLEditBrowserView getBrowserView() {
		return editorPreviewDialog;
	}*/
	
	public int handleFileChange(boolean xchng, boolean bRead, String sourcecontent) {

// Methode zur Behandlung einer geänderten Datei
		
		String content;
		String actualContent;
		File fileToRead;
		int action;
		
		if (sourcecontent != null) {
			actualContent = sourcecontent;
		} else {
			actualContent = editorView.getSourceContent();
		}
		if (xchng == true) {
			
// Eine Anderung zwischen den gelesenen Daten und den Daten aus dem View wurde gefunden
		
// Speicher-Dialog ausgeben
							
			action = editorView.showDataChangedDialog(editorModel.getActualSourceFile());
							
				if (action == JOptionPane.YES_OPTION) {
								
// Daten sichern und das neue File einlesen und anzeigen
								
					editorModel.writeFile(actualContent);
					if (bRead == true) {
					content = editorModel.readFile(editorView.getFileTree().getSelectedFile(), generateRandomFileNumber());
					editorView.setSourceContent(content, false);
					editorView.setSourceContextSuffix(editorModel.getActualSourceFileSuffix());
					
//					editorPreviewDialog.setPreviewURL(editorModel.getTempFile());
//					editorPreviewDialog.setBrowserContent(content, false);
					
					editorModel.setActualFileContent(editorView.getSourceContent());
// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
					if (editorView.getFileTree().getSelectedFile().isDirectory() == true) {
						editMode = false;
						editorView.setEditDisplayMode(editMode);
					}
					}
					editorView.showBookmarks(editorModel.getBookmarks());
								
				}
				else if (action == JOptionPane.NO_OPTION) {
								
// Daten nicht sichern, aber das neue File einlesen und anzeigen
			
					if (bRead == true) {
					content = editorModel.readFile(editorView.getFileTree().getSelectedFile(), generateRandomFileNumber());
					editorView.setSourceContent(content, false);
					
//					editorPreviewDialog.setPreviewURL(editorModel.getTempFile());
//					editorPreviewDialog.setBrowserContent(content, false);
					editorView.setSourceContextSuffix(editorModel.getActualSourceFileSuffix());
					
					editorModel.setActualFileContent(editorView.getSourceContent());
// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
					if (editorView.getFileTree().getSelectedFile().isDirectory() == true) {
						editMode = false;
						editorView.setEditDisplayMode(editMode);
					}
					editorView.showBookmarks(editorModel.getBookmarks());
					}
								
				}
				else if (action == JOptionPane.CANCEL_OPTION) {
								
// Datei nicht sichern und auf alter Selektion stehen bleiben - nichts zu tun
						
				}
							
			}
			else {
		// Keine Änderung - neu ausgewählte Datei laden und anzeigen
							
				action = JOptionPane.NO_OPTION;
				if (bRead == true) {
				content = editorModel.readFile(editorView.getFileTree().getSelectedFile(), generateRandomFileNumber());
				editorView.setSourceContent(content, false);
				editorModel.setActualFileContent(editorView.getSourceContent());

//				editorPreviewDialog.setPreviewURL(editorModel.getTempFile());
//				editorPreviewDialog.setBrowserContent(content, false);
				editorView.setSourceContextSuffix(editorModel.getActualSourceFileSuffix());

				
		// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
				if (editorView.getFileTree().getSelectedFile().isDirectory() == true) {
					editMode = false;
					editorView.setEditDisplayMode(editMode);
				}
				}
				editorView.showBookmarks(editorModel.getBookmarks());
			}

		return action;
	}
	
	public void setUserPrefs(){
		
		try {
			editorModel.storeUserPrefs("windowWidth", String.valueOf(frame.getSize().width));
			editorModel.storeUserPrefs("windowHeight", String.valueOf(frame.getSize().height));
/*			editorModel.storeUserPrefs("previewWindowWidth", String.valueOf(editorPreviewDialog.getSize().width));
			editorModel.storeUserPrefs("previewWindowHeight", String.valueOf(editorPreviewDialog.getSize().height));
			editorModel.storeUserPrefs("previewWindowLocationX", String.valueOf(editorPreviewDialog.getLocation().x));
			editorModel.storeUserPrefs("previewWindowLocationY", String.valueOf(editorPreviewDialog.getLocation().y));*/

// Aktuelles Verzeichnis nur sichern, wenn der Editor standalone aufgerufen wurde
			if (g_flg_mainframe == false) {
				editorModel.storeUserPrefs("lastUsedDirectory", projectDir);
			}
			
		} catch (BackingStoreException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
	
	public void setProjectDir(String newDir) {
		projectDir = newDir;
	}

 //   public static FTLEditControllerSWT getRef() {

    	// Statische Methode, um eine Referenz auf den Controller zu erhalten
    	    	
   // 	    	return g_rcl_controller;
 //   }
    void setupMacOSXApplicationListener() {
    	
    	// In dieser Methode wird dynamisch versucht, die entsprechenden Listener-Klassen
    	// für das Anwendungsmenü zu initialisieren, was nur auf Apple-Systemen funktioniert
    	// Gibt es die Klassen nicht, so wird der Laufzeitfehler abgefangen, so daß z.B.
    	// unter Windows kein Laufzeitfehler auftritt
    	    	
    	        try {
    	            // get mac os-x application class
    	            Class appc = Class.forName("com.apple.eawt.Application");
    	            // create a new instance for it.
    	            Object app = appc.newInstance();
    	            
    	            // get the application-listener class. here we can set our action to the apple menu
    	            Class lc = Class.forName("com.apple.eawt.ApplicationListener");
    	            Object listener = Proxy.newProxyInstance(lc.getClassLoader(), new Class[] { lc }, new InvocationHandler() {
    	                public Object invoke(Object proxy,Method method,Object[] args) throws Throwable {
    	                    if (method.getName().equals("handleQuit")) {
    	                    	
// Tastenkombination Apple + Q bzw. Quit aus dem Apple-Menue behandeln
    	                    	System.out.println("Apfel + Q");
 
// Prüfen, ob ungesicherte Änderungen vorhanden und den User entscheiden lassen, was er tun will
    	                    	
    	                    	handleApplicationClose("key");
    	            			
    	                    }
    	                    	else if (method.getName().equals("handlePreferences")) {
    	                        // show settings window
        	                    	System.out.println("Prefs");
    	                    }
    	                    	else if (method.getName().equals("handleAbout")) {
        	                    	System.out.println("About");
    	                        // show own aboutbox
//    	                        showAboutBox();
    	                        // set handled to true, so other actions won't take place any more.
    	                        // if we leace this out, a second, system-own aboutbox would be displayed
//    	                        com.apple.eawt.ApplicationEvent ae = (ApplicationEvent) args[0];
//    	                        ae.setHandled(true);
    	                    }
    	                    	
 //   	                    }

    	                    return null;
    	                }


    	            });

    	            try {
    	                // add application listener that listens to actions on the apple menu items
    	                Method m = appc.getMethod("addApplicationListener", lc);
    	                m.invoke(app, listener);
    	                // register that we want that Preferences menu. by default, only the about box is shown
    	                // but no pref-menu-item
//    	                Method enablePreferenceMethod = appc.getMethod("setEnabledPreferencesMenu", new Class[] {boolean.class});
//    	                enablePreferenceMethod.invoke(app, new Object[] {Boolean.TRUE});
    	            } catch (NoSuchMethodException ex) {
    	                ex.printStackTrace();
    	            } catch (SecurityException ex) {
    	                ex.printStackTrace();
    	            } catch (InvocationTargetException ex) {
    	                ex.printStackTrace();
    	            }
    	        }
    	        catch (ClassNotFoundException e) {
    	            e.printStackTrace();
    	        }
    	        catch (IllegalAccessException e) {
    	            e.printStackTrace();
    	        }
    	        catch (InstantiationException e) {
    	            e.printStackTrace();
    	        }
    	        
    }
    
    void handleApplicationClose (String calledFrom) {
    	
// Prüfen ob die aktuelle Datei ungesicherte Änderungen hat
    	
    	boolean xchng = false;
    	boolean bExit = true;
    	int action = 0;
    	JTabbedPane tabpan = editorView.getTabbedPanel();
		
		  int totalTabs = tabpan.getTabCount();
		  for(int i = 0; i < totalTabs; i++)
		  {
		     JPanel jps = (JPanel)tabpan.getComponentAt(i);
		     if(jps != null) {
	        	System.out.println(jps.getName());
	        	RSyntaxTextArea area = null;

	        	List<RSyntaxTextArea> areas = MXNewSourceTabFactory.findAllChildren((JComponent)tabpan.getComponentAt(i), RSyntaxTextArea.class);
	        	area = areas.get(0);

	        	Object[] openFile = editorModel.isFileAlreadyOpen(jps.getName());
					
				if (openFile != null) {
						editorModel.setActualFileContent((String)openFile[1]);
						editorModel.setActualSourceFile((File)openFile[2]);
						editorModel.setActualFileEncoding((Charset)openFile[3]);
				}
	        	xchng = this.getModel().isSourceFileChanged(jps.getName(), area.getText());
	        	action = this.handleFileChange(xchng, false, area.getText());
	        	if (action == JOptionPane.CANCEL_OPTION) {
	        		  bExit = false;
	        	}
//	        	  if (jps.getName().equals(absolutePath)) {
//	        		  jtpFlatFusionEditTabbedPane.setSelectedComponent(jps);
//	        		  break;
//	        	  }

		     }
		  }
//		boolean xchng = this.getModel().isSourceFileChanged(editorView.getSourceContent());
		
//Den Benutzer fragen, was er tun will
//		int action = this.handleFileChange(xchng);
		
//Wenn der Benutzer nicht "Abbrechen" gewählt hat, dann wurden die Anderungen gesichert oder verworfen
//also kann die Anwendung beendet werden
		
		if (bExit == true) {
			
			this.setUserPrefs();
// Die dispose-Methode verursacht unter Windows einen Fehler beim Beenden der Anwendung - daher Fenster nur auf unsichtbar setzen
//			editorPreviewDialog.closePreview();
//			editorPreviewDialog.setVisible(false); 

// Bei Aufruf als Stand-Alone-Anwendung - beenden
			
			if (g_flg_mainframe == false || (g_flg_mainframe == true && calledFrom == "key")) {
				System.exit(0);
			}
			else {
//Aufruf aus FlatFusion CMS - Fenster ausblenden
				this.frame.dispose();
			}
		} else {
// Im Model die Daten zur aktuell selektierten Datei wieder herstellen
			
			JPanel jpsact = (JPanel)tabpan.getSelectedComponent();
			
        	Object[] openFileAct = editorModel.isFileAlreadyOpen(jpsact.getName());
			
			if (openFileAct != null) {
					editorModel.setActualFileContent((String)openFileAct[1]);
					editorModel.setActualSourceFile((File)openFileAct[2]);
					editorModel.setActualFileEncoding((Charset)openFileAct[3]);
			}
		}
    }
    
    void initGlobalKeyListener() {
 
// Einen globalen Listener für AWT Events registrieren
// Innerhalb der Behandlermethode wird abgefragt, ob es sich
// um ein Tastaturereignis handelt
    	
	 	long eventMask = AWTEvent.KEY_EVENT_MASK;

		Toolkit.getDefaultToolkit().addAWTEventListener( new AWTEventListener()
		{
		    public void eventDispatched(AWTEvent e)
		    {
	            if(e instanceof KeyEvent)
	            	
	            {
	                KeyEvent keyEvent = (KeyEvent) e;
	                
	                if (keyEvent.getID() == KeyEvent.KEY_PRESSED) {

// Es wurden Tasten gedrückt - aber welche?
	                	   if (keyEvent.getKeyCode() == KeyEvent.VK_Q && keyEvent.isMetaDown()) {
	                		   
// Es wurde die Apple-Test zusammen mit Q gedrückt - normalerweise wird das automatisch über das AWT behandelt
// Im zusammenspiel mit dem SWT funktionieren die Menü-Ereignisse nicht mehr. Damit zumindest "Quit" über Apple + Q 
// noch geht, wird dies über diese Krücke hier simuliert
	                		   
	                		   System.out.println("keyCode: " + keyEvent.getKeyCode() + " = '" + keyEvent.getKeyChar() + "'");
// Behandlungsmethode für das Schliesen der Anwendung aufrufen mit der Info, dass der Aufruf durch ein Tastaturereignis ausgelöst wurde
	                		   handleApplicationClose("key");
	                		   } 
	                
	                }
	            }
		    }
		}, eventMask);
		
    }
    
	public String getSelectedText() {
		// TODO Auto-generated method stub
		return editorView.getEditorTextArea().getSelectedText();
	}

	public void searchEvent(SearchEvent e) {
		SearchEvent.Type type = e.getType();
		SearchContext context = e.getSearchContext();
		SearchResult result;

		switch (type) {
			default: // Prevent FindBugs warning later
			case MARK_ALL:
				result = SearchEngine.markAll(editorView.getEditorTextArea(), context);
				break;
			case FIND:
				result = SearchEngine.find(editorView.getEditorTextArea(), context);
				if (!result.wasFound()) {
					UIManager.getLookAndFeel().provideErrorFeedback(editorView.getEditorTextArea());
				}
				break;
			case REPLACE:
				if (editMode == true) {
					result = SearchEngine.replace(editorView.getEditorTextArea(), context);
					if (!result.wasFound()) {
						UIManager.getLookAndFeel().provideErrorFeedback(editorView.getEditorTextArea());
					}
				}
				break;
			case REPLACE_ALL:
				if (editMode == true) {
					result = SearchEngine.replaceAll(editorView.getEditorTextArea(), context);
					JOptionPane.showMessageDialog(null, result.getCount() + " " +
							messagebundle.getString("060"));
				}
				break;
		}

		
	} 
	
    private String generateRandomFileNumber() {

        Random r = new Random();
        Integer rnumber = r.nextInt((999999 - 100000) + 1) + 100000;
        return rnumber.toString();

    }
    
    private void setBookmarkAction() {

        editorView.getEditorTextArea().getActionMap().put("ToggleBookmark", new AbstractAction(){
        	
            public void actionPerformed(ActionEvent e) {

            	System.out.println("F2: Bookmarking");
            	HashMap<String, String> bookmarks = new HashMap();
            	try {
            		editorView.getScrollPaneEditorTextArea().getGutter().toggleBookmark(editorView.getEditorTextArea().getCaretLineNumber());
            	} catch (BadLocationException e1) {
                                   // TODO Auto-generated catch block
            		e1.printStackTrace();
                }

            	GutterIconInfo[] gutterinfos = editorView.getScrollPaneEditorTextArea().getGutter().getBookmarks();
            	DefaultTreeModel outlinemodel = (DefaultTreeModel)editorView.getBookmarkTree().getModel();
           		DefaultMutableTreeNode outlineroot = (DefaultMutableTreeNode)outlinemodel.getRoot();

           		outlineroot.removeAllChildren();
           		int startoffset = 0;
           		int endoffset = 0;
           		
            	for( int i = 0; i < gutterinfos.length; i++ ) {

           			int offset = gutterinfos[i].getMarkedOffset();

           			try {
           				startoffset = editorView.getEditorTextArea().getLineStartOffset(editorView.getEditorTextArea().getLineOfOffset(offset));
           			} catch (BadLocationException e2) {
                                              // TODO Auto-generated catch block
           				e2.printStackTrace();
           			}
           			try {
           				endoffset = editorView.getEditorTextArea().getLineEndOffset(editorView.getEditorTextArea().getLineOfOffset(offset));
           			} catch (BadLocationException e2) {
                                              // TODO Auto-generated catch block
           				e2.printStackTrace();
            		}
            		String line = null;
            		
            		try {
            			line = editorView.getEditorTextArea().getText(startoffset, endoffset - startoffset);
           			} catch (BadLocationException e1) {	
                                  // TODO Auto-generated catch block
           				e1.printStackTrace();
            		}

            		String[] tokens = { line, Integer.toString(offset) };
            		bookmarks.put(Integer.toString(offset), line);
            		OutlineTreeNode tokenNode = new OutlineTreeNode(tokens);

            		outlineroot.add(tokenNode);

            	}
            	outlinemodel.reload(outlineroot);
            	editorModel.storeBookmarks(bookmarks);
            	
            }

        });
        
    }
	/*######################################################################
	 * Lokale Listener Klasse für Outline JTree
	 *######################################################################
	 */
	
	private class OutlineTreeListener implements TreeSelectionListener {

		JTree treeobject;
		FTLEditController editcontroller;
		
		public OutlineTreeListener(JTree treeobj, FTLEditController controller) {
			
			treeobject = treeobj;
			editcontroller = controller;
			
		}
		public void valueChanged(TreeSelectionEvent selevent) {
			
			TreePath oldsel = selevent.getOldLeadSelectionPath();
			TreePath newsel = selevent.getNewLeadSelectionPath();
			
			if (oldsel != newsel && newsel != null) {
					
				Object node = newsel.getLastPathComponent();
				if (node instanceof JavaScriptTreeNode) {
					JavaScriptTreeNode jstn = (JavaScriptTreeNode)node;
					int len = jstn.getLength();
					if (len>-1) { // Should always be true
						int offs = jstn.getOffset();
						editcontroller.editorView.getEditorTextArea().setCaretPosition(offs);
					}
				} else  {
					DefaultMutableTreeNode node2 = (DefaultMutableTreeNode) newsel.getLastPathComponent();
					ArrayList selectedNodeAttribs = (ArrayList)node2.getUserObject();
					ASTNode attribs = (ASTNode)selectedNodeAttribs.get(0);
					editcontroller.editorView.getEditorTextArea().setCaretPosition(attribs.getNameStartOffset());
					System.out.println(attribs.getNameStartOffset());
				}
/*				DefaultMutableTreeNode node = (DefaultMutableTreeNode) newsel.getLastPathComponent();
				ArrayList selectedNodeAttribs = (ArrayList)node.getUserObject();
				ASTNode attribs = (ASTNode)selectedNodeAttribs.get(0);
				System.out.println(attribs);*/
				
//				editcontroller.editorView.getEditorTextArea().setCaretPosition(Integer.valueOf(tokens[1]));

			}
			
		}
	}   
	/*######################################################################
	 * Lokale Listener Klasse für JTree
	 *######################################################################
	 */
	
	private class FileTreeListener implements TreeSelectionListener {

		FileTree treeobject;
		FTLEditController editcontroller;
		TreePath oldselrestored = null;
		
		public FileTreeListener(FileTree treeobj, FTLEditController controller) {
			
			treeobject = treeobj;
			editcontroller = controller;
			
		}
		public void valueChanged(TreeSelectionEvent selevent) {
			
			TreePath oldsel = selevent.getOldLeadSelectionPath();
			TreePath newsel = selevent.getNewLeadSelectionPath();
			
			if (oldsel != newsel) {
				
				
				if (oldselrestored == newsel) {
					
					oldselrestored = null;
				}
				else {
					
					int action = 0;
					
					Object[] openFile = editorModel.isFileAlreadyOpen(treeobject.getSelectedFile().getAbsolutePath());
				
					if (openFile != null) {
					
						editorView.selectTabForFile(treeobject.getSelectedFile().getAbsolutePath());
						editorView.setEditDisplayMode(editorView.getEditorTextArea().isEditable());
						editMode = editorView.getEditorTextArea().isEditable();
						editorModel.setActualFileContent((String)openFile[1]);
						editorModel.setActualSourceFile((File)openFile[2]);
						editorModel.setActualFileEncoding((Charset)openFile[3]);
						editorView.setSourceContextSuffix(editorModel.getActualSourceFileSuffix());

					
					} else if (openFile == null && treeobject.getSelectedFile().isFile()){

						editorModel.setActualFileContent("");
						editorModel.setActualSourceFile(null);
						editorModel.setActualFileEncoding(null);
						editorView.addTabForFile(treeobject.getSelectedFile());
						editMode = false;
						action = editcontroller.handleFileChange(false, true, null);
						// Bookmarks setzen/loeschen fuer Editor-Textarea
				        InputMap imEditorArea = editorView.getEditorTextArea().getInputMap(JComponent.WHEN_FOCUSED);
				        imEditorArea.put(KeyStroke.getKeyStroke("ctrl pressed F2"), "ToggleBookmark");
				// Suchen/Ersetzen Dialog
				        imEditorArea.put(KeyStroke.getKeyStroke("ctrl pressed H"), "Replace");
				        editorView.getEditorTextArea().getActionMap().put("Replace", new ShowReplaceDialogAction());
				        editcontroller.setBookmarkAction();
					
					}
// Prüfen ob der Quellcode geändert wurde
				
//				boolean xchng = editorModel.isSourceFileChanged(editorView.getSourceContent());
				
//				int action = editcontroller.handleFileChange(false);
				
				if (action == JOptionPane.CANCEL_OPTION) {

// Daten nicht sichern und auf dem bisher selektierten File stehen bleiben	
// Die aktuelle alte Selektion sichern - dies dient zum Vergleich, da der Listener direkt nach
// dem erneuten Setzen der bisherigen Selektion wieder angesprochen wird. Hier wird nun verglichen
// ob die neue Selektion der zurückgesetzten Selektion entspricht. Ist dies der Fall, wird die
// Prüfung auf Änderungen nicht nochmal gemacht, da sonst eine Endlossschleife entsteht
					oldselrestored = oldsel;
// Bisherige Selektion wieder als aktuelle Selektion setzen
					treeobject.setSelectionPath(oldsel);
				}
				
/*				if (xchng == true) {
// Eine Änderung zwischen den gelesenen Daten und den Daten aus dem View wurde gefunden
					
// Speicher-Dialog ausgeben
					
					int action = editorView.showDataChangedDialog(editorModel.getActualSourceFile());
					
					if (action == JOptionPane.YES_OPTION) {
						
// Daten sichern und das neue File einlesen und anzeigen
						
						editorModel.writeFile(editorView.getSourceContent());
						content = editorModel.readFile(treeobject.getSelectedFile());
						editorView.setSourceContent(content, false);
						editorModel.setActualFileContent(editorView.getSourceContent());
// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
						if (treeobject.getSelectedFile().isDirectory() == true) {
							editMode = false;
							TokenStyles.setEditMode(editMode);
							editorView.setEditDisplayMode(editMode);
						}
						
					}
					else if (action == JOptionPane.NO_OPTION) {
						
// Daten nicht sichern, aber das neue File einlesen und anzeigen
	
						content = editorModel.readFile(treeobject.getSelectedFile());
						editorView.setSourceContent(content, false);
						editorModel.setActualFileContent(editorView.getSourceContent());
// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
						if (treeobject.getSelectedFile().isDirectory() == true) {
							editMode = false;
							TokenStyles.setEditMode(editMode);
							editorView.setEditDisplayMode(editMode);
						}
						
					}
					else if (action == JOptionPane.CANCEL_OPTION) {
						
// Daten nicht sichern und auf dem bisher selektierten File stehen bleiben	
// Die aktuelle alte Selektion sichern - dies dient zum Vergleich, da der Listener direkt nach
// dem erneuten Setzen der bisherigen Selektion wieder angesprochen wird. Hier wird nun verglichen
// ob die neue Selektion der zurückgesetzten Selektion entspricht. Ist dies der Fall, wird die
// Prüfung auf Änderungen nicht nochmal gemacht, da sonst eine Endlossschleife entsteht
						oldselrestored = oldsel;
// Bisherige Selektion wieder als aktuelle Selektion setzen
						treeobject.setSelectionPath(oldsel);
					}
					
				}
				else {
// Keine Änderung - neu ausgewählte Datei laden und anzeigen
					
					content = editorModel.readFile(treeobject.getSelectedFile());
					editorView.setSourceContent(content, false);
					editorModel.setActualFileContent(editorView.getSourceContent());
// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
					if (treeobject.getSelectedFile().isDirectory() == true) {
						editMode = false;
						TokenStyles.setEditMode(editMode);
						editorView.setEditDisplayMode(editMode);
					}
				}*/

				}
			}
			
		}
	}

	/*######################################################################
	 * Lokale Listener Klasse für Buttons
	 *######################################################################
	 */
	
	private class ButtonListener implements ActionListener {
		
		FTLEditController editcontroller;
		
		public ButtonListener(FTLEditController controller) {
			editcontroller = controller;
		}

		public void actionPerformed(ActionEvent event) {

			String filePath;
			String dirPath;
			String fileName;
			String l_var_file_to_delete;
			TreePath actPath;
			TreePath oldPath = null;
			boolean l_var_file;
			boolean empty_dir = false;

			DefaultMutableTreeNode actNode;
			DefaultMutableTreeNode newNode;

			
// ### Anzeige/Ändern-Button
			
			if (event.getActionCommand().equals("ToggleEditDisplay")) {
				
// Je nach aktuellem Status den Editor der GUI auf Editieren oder Anzeigen schalten
// und Status ändern
				
				if (editMode == false) {

					if (editorModel.getActualSourceFile() != null) {
						editMode = true;
						editorView.setEditDisplayMode(editMode);
					}


				}
				else if (editMode == true) {

					editMode = false;
			        editorView.setEditDisplayMode(editMode);


				}
				
			}
			
// ### Speichern-Button
			
			else if (event.getActionCommand().equals("Save")) {

// Aktuelle Datei speichern und für den nächsten Vergleich den aktuellen
// Inhalt des Editorbereichs ins Model übertragen
				
				if (editMode == true) {
					editorModel.writeFile(editorView.getSourceContent());
					editorModel.writeTempFile(editorView.getSourceContent());
					editorModel.setActualFileContent(editorView.getSourceContent());
				}
				
			}
			
// ### "Neue Datei"-Button
			
			else if (event.getActionCommand().equals("NewFile")) {
				
// Erstmal prüfen, ob die aktuell offene Datei gesichert werden muß
				
//				boolean xchng = editorModel.isSourceFileChanged(editorView.getSourceContent());
				
// Benutzer fragen, ob er sichern will oder nicht
				
//				int action = editcontroller.handleFileChange(xchng);
	
// Benutzer hat nicht "Abbrechen" gewählt, was bedeuten würde, daß auf der nicht gesicherten
// Datei stehen geblieben werden muß
				
//				if (action != JOptionPane.CANCEL_OPTION) {
					
// Das übergeordnete Verzeichnis der aktuellen Auswahl ermitteln
				
					fileName = editorView.showFileNameDialog();
				
					if (fileName != null) {

// Je nachdem, ob die aktuelle Auswahl eine Datei oder ein Verzeichnis ist, das übergeordnete
// Verzeichnis oder den aktuellen absoluten Pfad holen
						
						if (editorView.getFileTree().getSelectedFile().isFile()) {
	
							filePath = editorView.getFileTree().getSelectedFile().getParent();
						}
						else {
					
							filePath = editorView.getFileTree().getSelectedFile().getAbsolutePath();
						}
				
// Absoluten Pfadnamen zu neuer Datei erzeugen
				
						String newFile = filePath + File.separator + fileName;

// Prüfen, ob die Datei schon vorhanden ist
						if (editorModel.isFileExisting(newFile) == false) {

// Je nachdem, ob die aktuelle Auswahl eine Datei oder ein Verzeichnis ist, den Pfad zur aktuellen Selektion
// im Verzeichnisbaum oder den Pfad zum übergeordneten Knoten holen und Flag "Datei" setzen
// Im Fall einer Datei den übergeordnete Pfad für später merken
							
							if (editorView.getFileTree().getSelectedFile().isDirectory()) {
// Aktuell selektierten JTree-Pfad holen und den aktuellen Knoten ermitteln

								actPath = editorView.getFileTree().getSelectionPath();
								oldPath = editorView.getFileTree().getSelectionPath();
								actNode = (DefaultMutableTreeNode) actPath.getLastPathComponent();
								
								File fi = (File) actNode.getUserObject();

// Prüfen, ob das ausgewählte Verzeichnis Dateien enthält - falls nicht, dieses zuklappen und Kennzeichen "leeres Verzeichnis" setzen
								if (fi.listFiles().length == 0) {
									empty_dir = true;
									editorView.getFileTree().collapsePath(editorView.getFileTree().getSelectionPath());
								}
								
// Falls der markierte Ordner zugeklappt ist, diesen aufklappen (ausser wenn er leer ist), sonst kann die neu eingefügte Datei nicht markiert werden
								if (editorView.getFileTree().isCollapsed(editorView.getFileTree().getSelectionPath()) == true && empty_dir == false) {
									editorView.getFileTree().expandPath(editorView.getFileTree().getSelectionPath());
								}
								
								l_var_file = false;
							}
							else {

								actPath = editorView.getFileTree().getSelectionPath().getParentPath();
								oldPath = editorView.getFileTree().getSelectionPath().getParentPath();
								l_var_file = true;
								empty_dir = false;
							}
						
// Datei ins Model übertragen und speichern
						
							editorModel.setActualFileContent("");
							editorModel.setActualFileName(newFile);
							editorModel.setActualFileEncoding(Charset.defaultCharset());

							editorModel.writeFile("");
							
							editorView.addTabForFile(new File(newFile));
							editorView.selectTabForFile(newFile);
							editorView.setSourceContent("", false);
							
							editorModel.readFile(new File(newFile), editorController.generateRandomFileNumber());
						
							actNode = (DefaultMutableTreeNode) actPath.getLastPathComponent();
					
// Verzeichnis war nicht leer oder es war eine Datei ausgewählt
							if (empty_dir == false) {

// Neuen Knoten mit Dateiobjekt erzeugen
								newNode = new DefaultMutableTreeNode(new File(newFile));					

// Neuen Knoten als neues Blatt im aktuellen Knoten ganz zum Schluß anfügen
								((DefaultTreeModel) editorView.getFileTree().getModel()).insertNodeInto(newNode, actNode, actNode.getChildCount());
					
// Den aktuell selektierten Knoten aktualisieren
								((DefaultTreeModel) editorView.getFileTree().getModel()).reload(actNode);
							
// Nach der Aktualisierung Pfad- und Knotenobjekt der aktuellen Auswahl neu holen
						
								if (l_var_file == false) {
// Es war ein Verzeichnis selektiert - den aktuellen Pfad aus der immer noch gültigen Selektion bestimmen								
									actPath = editorView.getFileTree().getSelectionPath();
									if (actPath == null) {
										actPath = oldPath;
									}
								}
								else {
// Es war eine Datei selektiert, das übergeordnete Element aus der zuvor gültigen gemerkten Selektion bestimmen								
									actPath = oldPath;
								}
						
								actNode = (DefaultMutableTreeNode) actPath.getLastPathComponent();
				
// Jetzt den gerade neu hinzugefügten Knoten im Baum markieren. Der neu hinzugefügte Knoten ist der letzte Kindknoten der aktuellen Auswahl
// Mit getPathToRoot kann über das Model ein Objekt-Array mit dem vollständigen Pfad bis zu diesem Kindknoten geholt werden
// Dieses wird als aktuelle Auswahl im Tree gesetzt
// Dann noch, falls erforderlich, den Verzeichnisbaum zum ausgewählten Knoten scrollen
				
								editorView.getFileTree().setSelectionPath(new TreePath(((DefaultTreeModel) editorView.getFileTree().getModel()).getPathToRoot(actNode.getLastChild())));
								editorView.getFileTree().scrollPathToVisible(new TreePath(((DefaultTreeModel) editorView.getFileTree().getModel()).getPathToRoot(actNode.getLastChild())));
							
							}
							else {
								
// Anderes Handling für eine leeres Verzeichnis 
								
// Den zuvor bei leerem Verzeichnis geschlossenen Knoten wieder aufklappen
								editorView.getFileTree().expandPath(editorView.getFileTree().getSelectionPath());
// Aktuell gültige Selektion bestimmen
								actPath = editorView.getFileTree().getSelectionPath();
								actNode = (DefaultMutableTreeNode) actPath.getLastPathComponent();
// Da der Ordner leer war, einfach den ersten Kindknoten markieren
								editorView.getFileTree().setSelectionPath(new TreePath(((DefaultTreeModel) editorView.getFileTree().getModel()).getPathToRoot(actNode.getFirstChild())));
							}
						}
						else {
// Der eingegeben Dateiname existiert schon - Fehler ausgeben
						
						editorView.showFileExistsDialog(newFile);
						}
					}
//				}
				
			}
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ### Vorschau-aktualisieren-Button
			
			else if (event.getActionCommand().equals("Refresh")) {
				
				editorView.setSourceContent(editorView.getSourceContent(), true);
				editorModel.writeTempFile(editorView.getSourceContent());
				try {
					BareBonesBrowserLaunch.openURL(editorModel.getTempFile().toURI().toURL().toString());
				} catch (MalformedURLException e) {
					// TODO Auto-generated catch block
					e.printStackTrace();
				}
//				editorPreviewDialog.setPreviewURL(editorModel.getTempFile());
//				editorPreviewDialog.setBrowserContent(editorView.getSourceContent(), true);
				
			}

// ### Datei-Löschen-Button
			
			else if (event.getActionCommand().equals("RemoveFile")) {
				
				if (editorView.getFileTree().getSelectedFile().isFile()) {
					
					int action = editorView.showFileDeleteDialog(editorView.getFileTree().getSelectedFile());
					
					if (action == JOptionPane.YES_OPTION) {
						
						actPath = editorView.getFileTree().getSelectionPath().getParentPath();
						actNode = (DefaultMutableTreeNode) actPath.getLastPathComponent();
						
						l_var_file_to_delete = editorView.getFileTree().getSelectedFile().getAbsolutePath();
						editorView.getFileTree().collapsePath(editorView.getFileTree().getSelectionPath().getParentPath());
						editorModel.deleteFile(l_var_file_to_delete);
						editorView.getFileTree().expandPath(editorView.getFileTree().getSelectionPath());
						editorView.getFileTree().setSelectionPath(new TreePath(((DefaultTreeModel) editorView.getFileTree().getModel()).getPathToRoot(actNode)));
					}
					
				}

				else {

// Dialog ausgeben, der darauf hinweist, daß eine Datei ausgewählt werden muß
					
					editorView.showNoDirectoryDialog();
					
				}
			}
			
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ### Verzeichnis-wechseln-Button
										
			else if (event.getActionCommand().equals("ChangeDir")) {
											
// Erstmal prüfen, ob die aktuell offene Datei gesichert werden muß
				
//				boolean xchng = editorModel.isSourceFileChanged(editorView.getSourceContent());
				
// Benutzer fragen, ob er sichern will oder nicht
				
//				int action = editcontroller.handleFileChange(xchng);
	
// Benutzer hat nicht "Abbrechen" gewählt, was bedeuten würde, daß auf der nicht gesicherten
// Datei stehen geblieben werden muß
				
//				if (action != JOptionPane.CANCEL_OPTION) {
					
					if (editorView.getFileTree().getSelectedFile().isDirectory()) {
						
						dirPath = editorView.getFileTree().getSelectedFile().getAbsolutePath();
					}
					else {
						
						dirPath = editorView.getFileTree().getSelectedFile().getParent();
					}
					
					String newDir = editorView.showDirectoryChooser(dirPath);
					
					if (newDir.equals(dirPath) == false) {
						
						editorView.getFileTree().changeRoot(newDir);
						editorView.getFileTree().setSelectionRow(0);
						String content = editorModel.readFile(editorView.getFileTree().getSelectedFile(), generateRandomFileNumber());
						editorView.setSourceContent(content, false);
						editorModel.setActualFileContent(editorView.getSourceContent());
						editorView.setSourceContextSuffix(editorModel.getActualSourceFileSuffix());
	// Falls neue Auswahl ein Verzeichnis ist - Änderungsmodus deaktivieren	
						if (editorView.getFileTree().getSelectedFile().isDirectory() == true) {
							editMode = false;
							editorView.setEditDisplayMode(editMode);
						}
						editcontroller.setProjectDir(newDir);
						
//					}
				}
			
			}
			else if (event.getActionCommand().equals("Preferences")) {

// Hashtable erzeugen und alle für den Einstellungs-Dialog relevante Key/Value Paare aus dem Model hineinschreiben
				Hashtable preftab = new Hashtable();
// Zu verwendendes Dateiencoding beim Speichern - Voreinstellung ist FILE = Encoding von Datei übernehmen
				preftab.put("saveEncoding", editorModel.getUserPrefs().get("saveEncoding", "FILE"));
				
				if (editorPreferencesView == null) {
					  
					editorPreferencesView = new FTLEditPreferencesView(frame, messagebundle.getString("019"), true, currentlocale);
					editorPreferencesView.setPreferences(preftab);
					editorPreferencesView.setVisible(true);

				}
				else {
					editorPreferencesView.setPreferences(preftab);
					editorPreferencesView.setVisible(true);
				}

				int action = editorPreferencesView.getAction();
				
				if (action == 1) {
					try {
						editorModel.storeUserPrefs("saveEncoding", editorPreferencesView.getPreferences().get("saveEncoding").toString());
					} catch (BackingStoreException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					}
				}
				else if (action == 2) {
					editorPreferencesView.setPreferences(preftab);
				}
			
			}
			else if (event.getActionCommand().equals("FindNext") || event.getActionCommand().equals("FindPrev")) {
			
// "FindNext" => search forward, "FindPrev" => search backward
			      String command = event.getActionCommand();
			      boolean forward = "FindNext".equals(command);	
// Create an object defining our search parameters.
			      SearchContext context = new SearchContext();
			      String text = editorView.getSearchTextField().getText();
			      if (text.length() == 0) {
			         return;
			      }
// Alte Position des Cursors vor der nächsten Suche sichern
			      
			      int oldpos = editorView.getEditorTextArea().getCaretPosition();
			      context.setSearchFor(text);
			      context.setMatchCase(false);
			      context.setRegularExpression(false);
			      context.setSearchForward(forward);
			      context.setWholeWord(false);
			      context.setMarkAll(true);

			      if (SearchEngine.find(editorView.getEditorTextArea(), context).wasFound()) {

// Neue Cursorposition nach dem nächsten Suchtreffer sichern
			    	  int actpos = editorView.getEditorTextArea().getCaretPosition();
			    	
// Wenn rückwärts gesucht wird und der neue Suchtreffer dem alten entspricht, stand der Cursor noch
// direkt hinter dem Suchbegriff 			    	 
			    	  if (forward == false && actpos == oldpos) {
// Cursor vor den Suchbegriff setzen
			    		  editorView.getEditorTextArea().setCaretPosition(actpos - text.length());
// Neu suchen und die neue Cursorpostion ermitteln
			    		  SearchEngine.find(editorView.getEditorTextArea(), context);
			    		  actpos = editorView.getEditorTextArea().getCaretPosition();
//			    		  actres = SearchEngine.getNextMatchPos(text, editorView.getSourceContent(), forward, false, false);
			    	  }
//			    	  actres = actres + text.length();
//			    	  if (oldactpos != (actpos - actres)) {
//			    		  String searchstring = editorView.getSourceContent().substring(actpos);
//			    		  int res = SearchEngine.getNextMatchPos(text, searchstring, forward, false, false);
//			    	  	if (forward == false) {
//			    	  		actpos = actpos - text.length();
//			    	  	} 
// Cursor hinter den neuen Suchtreffer setzen
			    	  editorView.getEditorTextArea().setCaretPosition(actpos);
			    	  editorView.getEditorTextArea().requestFocusInWindow();
//			    	  }
			      }
			}
			
		}

	}
	
	private class EditorWindowListener extends WindowAdapter {
		
		FTLEditController editcontroller;
		
		public EditorWindowListener(FTLEditController controller) {
			
			editcontroller = controller;

		}
		
		public void windowClosing (WindowEvent ev) {

			editcontroller.handleApplicationClose("gui");
/*
// Prüfen ob die aktuelle Datei ungesicherte Änderungen hat
			
			boolean xchng = editcontroller.getModel().isSourceFileChanged(editmainview.getSourceContent());x
			
// Den Benutzer fragen, was er tun will
			int action = editcontroller.handleFileChange(xchng);
			
// Wenn der Benutzer nicht "Abbrechen" gewählt hat, dann wurden die Änderungen gesichert oder verworfen
// also kann die Anwendung beendet werden
			
			if (action != JOptionPane.CANCEL_OPTION) {
				
				editcontroller.setUserPrefs();
				editpreview.closePreview();

// Bei Aufruf als Stand-Alone-Anwendung - beenden
				
				if (editcontroller.g_flg_mainframe == false) {
					System.exit(0);
				}
				else {
// Aufruf aus FlatFusion CMS - Fenster ausblenden
					editcontroller.frame.dispose();
				}
			}*/
		}
		
		
	}

	public class MXJTabbedPaneEventListener implements FTLEditEventListener {
		
		FTLEditController editcontroller;
		
		public MXJTabbedPaneEventListener(FTLEditController controller) {
			
			editcontroller = controller;

		}
		
		public boolean handleJTabbedPaneClose() {
			// TODO Auto-generated method stub

			boolean bCanClose = true;
		     JPanel jps = (JPanel)editorView.getTabbedPanel().getComponentAt(editorView.getTabbedPanel().getSelectedIndex());
		     if(jps != null) {
	        	System.out.println(jps.getName());
	        	RSyntaxTextArea area = null;

	        	List<RSyntaxTextArea> areas = MXNewSourceTabFactory.findAllChildren((JComponent)editorView.getTabbedPanel().getComponentAt(editorView.getTabbedPanel().getSelectedIndex()), RSyntaxTextArea.class);
	        	area = areas.get(0);

	        	boolean xchng = editorModel.isSourceFileChanged(jps.getName(), area.getText());
	        	int action = editcontroller.handleFileChange(xchng, false, area.getText());
	        	if (action != JOptionPane.CANCEL_OPTION) {
	        		bCanClose = true;
	        		editorModel.removeAlreadyOpenFile(jps.getName());
	        	} else {
	        		bCanClose = false;
	        	}
		     }
		     return bCanClose;
		}
		
	}
	  /**
	   * Shows the Replace dialog.
	   */
	  public class ShowReplaceDialogAction extends AbstractAction {

	  	ShowReplaceDialogAction() {
	  		super(messagebundle.getString("059"));
	  		int c = editorView.getToolkit().getMenuShortcutKeyMask();
	  		putValue(ACCELERATOR_KEY, KeyStroke.getKeyStroke(KeyEvent.VK_H, c));
	  	}

	  	public void actionPerformed(ActionEvent e) {

	  		editorView.getReplaceDialog().setVisible(true);
	  	}


	  }
	  

	
/*	public class EditorMessageHandler implements ApplicationMessageHandler {

		public EditorMessageHandler(FTLEditController controller) {
			editcontroller = controller;
		}
		FTLEditController editcontroller;
		
		public void handleQuit() {
// Prüfen ob die aktuelle Datei ungesicherte Änderungen hat

			System.out.println("Quit FTLEdit 0.3");
//			editcontroller.handleApplicationClose("gui");
			
		}
		
	}*/
	
}
